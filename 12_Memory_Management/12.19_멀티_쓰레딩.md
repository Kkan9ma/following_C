# 12.19 멀티 쓰레딩 Multi-Threading

<img src="https://github.com/uber9ma/following_C/blob/master/images/chapter12/alloc15.png?raw=true">

* C++에서 효율적이나, C에서도 사용할 수 있음.

## 멀티 쓰레딩?
* 프로그램을 만들고, 실행시킨다.
    - 프로세스에서 실행.
* 프로세스 실행
    - 주된 쓰레드(Thread)(프로그램 흐름)가 있는데, 메인 쓰레드가 다른 쓰레드를 만들어 일을 시킬 수 있다. 
    - 동시성 프로그래밍
    - 시점마다 쓰레드의 개수가 다르고, 프로그램 실행 가능 수도 많아짐.

## 생각해볼 점
### 하나의 함수를 여러 쓰레드가 동시에 실행시킨다면?
* 메모리엔 여러 쓰레드만큼 개수가 생겨야 하고, 함수 내 변수도 쓰레드만큼 존재해야 한다.
    - 3개의 쓰레드가 실행 => 3개의 메모리 내 함수와 변수

### 하나의 전역 변수를 여러 쓰레드가 동시에 실행시키려 한다면?
* 경쟁이 생긴다.
* 데이터는 메모리에 저장되고, 메모리는 사용되기 위해 cpu로 갈 때 레지스터를 거친다.
    - 또한 cpu의 연산 후엔, 다시 메모리에 위치한다.

* 이럴 경우 다음과 같은 문제의 가능성이 있다.
    - 한 쓰레드가 메모리를 가져와서 작업을 하는 사이, 다른 쓰레드가 그 메모리를 가져가 주소를 바꾼다든지 등의 작업을 한다면?


## 실습
* 멀티 쓰레딩은 C 표준엔 없음. 운영체제가 제공하는 API를 사용하게 됨.

### GCC 표준
<img src="https://github.com/uber9ma/following_C/blob/master/images/chapter12/thread1.png?raw=true">

* `<pthread.h>`: windows에서도 사용 가능.

* `thread_id`: 쓰레드 간 식별.
    - 용도 측면에선 변수나 포인터와 유사한 점이 있음.

* `pthread_create(&thread_id1, NULL, myThreadFun, NULL);`
    - `myThreadFun`을 실행시키는 쓰레드를 실행시킴.
    - 그리고 그 쓰레드에 대한 식별자를 `&thread_id1`로 받음.
* id2도 마찬가지
* 일시적으로 thread1에서도 thread2에서도 `int n = 1;`에서 사용하는 메모리를 갖고 있음.

* `_Atomic`: 각각의 쓰레드가 동일한 전역변수에 접근하려 할 때 동시에 편집하지 않도록 막아줌.
    -  racing condition에 대한 문제를 막아줌.
    - `<stdatomic.h>`
    - `_Atomic` 변수는 속도가 느려서 반복되게 계속 연산하는 건 별로 좋지 않음.

* `pthread_join(thread_id1, NULL)`
    - 쓰레드가 끝날 때까지 기다린다.
    - 다른 쓰레드가 하는 일이 많은데 메인 쓰레드(프로그램)가 먼저 끝난다면?
    - 이를 방지
    