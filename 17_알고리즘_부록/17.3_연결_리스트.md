# 17.3 연결 리스트 Linked List
* 배열과 연결 리스트를 비교해보기.

## 배열
<img src="https://github.com/uber9ma/following_C/blob/master/images/chapter17/array1.png?raw=true" width="1000">

* 아무리 많은 데이터이더라도 모든 원소를 하나 씩 밀어줘야 함.
* 컴파일 타임에 데이터 크기를 저장해야 해서 비효율적일 가능성도 있음. (동적할당으로 보완 가능)
    - 동적할당 역시 전체 데이터를 resizing, reallocating 할 때마다 전체 데이터르 모두 복사해와야 한다는 불편한 점이 있음.

### 배열의 장단점 정리
<img src="https://github.com/uber9ma/following_C/blob/master/images/chapter17/array2.png?raw=true" width="1000">

* 캐시 메모리 성능이 좋아, 효율이 좋음.
* 포인터 연산 용이.

## 연결되어 있는 리스트 (연결 리스트, Linked List)
<img src="https://github.com/uber9ma/following_C/blob/master/images/chapter17/linkedlist1.png?raw=true" width="1000">

* Linked List와 Array의 차이
    - Array
        - 모든 데이터를 넣을 수 있는 공간을 가져와서 하나 씩 순차적으로 넣는다.
        - 통짜로 메모리를 받아옴.
        - 쭉 나열되어 있기 때문에 다음 데이터가 어디에 있는지 금방 알 수 있음.
    - Linked List
        - 하나 씩 떨어져 있고, 빈 칸이 있고, 화살표가 있음.
        - Head가 있음.
        - 데이터 item을 하나하나 받아옴.
        - `malloc()` 함수로, 운영체제로부터 메모리를 그때그때 필요할 때마다 가져옴.
        - 데이터를 각각 가져오기 때문에 다음 데이터가 순차적으로 있지 않고, 다음 데이터의 위치는 운영체제가 할당해줄 때 결정됨. 미리 가정하거나 알 수 없음. 
        - 앞 데이터에 다음 데이터를 가리키는 포인터를 저장하는 공간을 두고, 포인터로 연결-연결-연결하는 구조.
        - 제일 처음 데이터를 가리키기 위해 생기는 포인터가 HEAD
        - 데이터를 추가하거나 삭제할 때 효율적임.
        - 접근은 __순차 접근 sequential access__ 만 가능함.

## 연결 리스트의 새로운 아이템 추가, 삭제
<img src="https://github.com/uber9ma/following_C/blob/master/images/chapter17/linkedlist2.png?raw=true" width="1000">

* 연결 관계만 살짝 변경
    - 메모리 주소는 일렬로 저장되어 있지 않을지라도, 원하는 대로 순서를 만들어 연결해줄 수 있음.

<img src="https://github.com/uber9ma/following_C/blob/master/images/chapter17/linkedlist3.png?raw=true" width="1000">

* 운영체제에 메모리를 반납.

## 배열과 연결 리스트 비교
<img src="https://github.com/uber9ma/following_C/blob/master/images/chapter17/linkedlist4.png?raw=true" width="1000">

* 배열에선 주로 요소라는 이름, 자료구조에선 주로 아이템을 사용.
    - 몇 번째 요소다, 이런 예시로는 '요소'
    - 데이터 자체에 대해 집중할 땐 '~~ 데이터 아이템' 등의 용어를 사용.

* 노드: Linked-List에선 데이터 자체인 item과 다음 데이터를 가리키는 포인터를 아울러 __노드__ 라 함.
    - 그래프 관련 부분에서 많이 접할 예정

#### '장단점과 관련하여' 메모
* 비효율적인 메모리 사용
    - 배열은 데이터를 변경할 때, 사본을 만든 후 작업해야 하기 때문에 일시적으로 매우 비효율적인 메모리 사용이 발생함.