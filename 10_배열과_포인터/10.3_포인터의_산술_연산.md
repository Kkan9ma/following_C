# 10.3 포인터의 산술 연산 Pointer Arithmetic

## 예제 1

- 포인터 값이 0이라 가정. (NULL이 아닌 이유)

<img src="https://github.com/uber9ma/following_C/blob/master/images/chapter10/array5.png?raw=true">

- 연산
  - int: 1을 더했지만 4가 더해진다. 2 => 8
  - char: 1 => 1, 2 => 2
  - double: 1 => 8, 2 => 16
  - long long: 1 => 8, 2 => 16

* 포인터에 1을 더하는 것은 자료형의 사이즈만큼 더하는 연산이 된다.
  - 빼기 역시 마찬가지

- void형 포인터라면 자료형의 사이즈를 알 수 없어서 연산 불가.
  - cf) void형 포인터는 하드웨어 관련, 고효율 최적화 등에서 주로 사용됨.

## 예제 2

- 단항 연산자로서의 연산은 아예x
  - ex) `ptr = -ptr`, `ptr = +ptr`
  - 주소값을 음수로 만드는 것이 의미가 없으므로.


                double arr[10]
                double* ptr1 = &arr[3];
                double* ptr2 = &arr[5];

                ptr2 = ptr1 + ptr2; // Not working
                int i = ptr2 - ptr1;

                printf("%p %p %d\n", ptr1, ptr2, i);

- 주소끼리 더하는 것은 의미 없음.
- 주소끼리 빼는 것은 됨.
  - **거리의 의미**: 실제 메모리는 1열로 쭉 되어 있음.
    - 주어진 자료형 사이즈만큼 몇 칸 건너가있는지 확인.
